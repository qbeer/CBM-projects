Feladatok felosztása több szálra:
  c++11 feature számjegy elválasztás 10'000 (tíz ezer)
  std::thread::hardware_concurrency -> megmondja, hogy az oprendszer hány logikai(! magot tud egyszerre futtatni
  std::future -> szálak visszadott értékének előhívásásra jó (nagyon pontatlan megfogalmazás)
  // példakódok később jönnek még ám ide
  async !
  felösszegzés: std::accumulate
  
Két fő adatcsoport:
  meg van-e osztva?
  const vagy nem const?
  race condition -> két szál ugyan azt az adatot akarja írni, sérülhet az adat (!)
    erre megoldás a mutex (mutual exclusion)
  deadlock
  
// szálkezeléses blokk vége (ez itt jó hiányos, órán több volt)

Atomic műveletek:
  néhány egyszerű művelethez van csak ilyen
  c++11 std::atomic<T> 
    csak néhány típusra lesz ez tényleg atomic
    store and load, swap, swap if, &, ||, XOR, +, -
   nem lehet tárolót létrehozni atomic<T>-ből
    kell írni egy struktúrát amit már lehet másolni
   
// ez az egész jó bonyi
  
  
 
 
